# -*- coding: utf-8 -*-
"""Imersão IA Alura + Google Gemini - Agente de analise de dados

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DcPGAZC_kFCIaCUsfp1V--aCTYPfMWHZ
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install -U -q google-genai
# %pip install -U -q google-adk

# Configura a API Key do Google Gemini

import os
from google.colab import userdata

os.environ["GOOGLE_API_KEY"] = userdata.get('GOOGLE_API_KEY')

# Configura o cliente da SDK do Gemini

from google import genai
from google.genai import types # Necessário para tipos como Content e Part

client = genai.Client()

MODEL_ID = "gemini-2.0-flash"

# Exemplo Básico de Chamada ao Gemini (Sem Ferramentas)
from IPython.display import HTML, Markdown # Para exibir texto formatado

# Perguntar pro modelo quando é a próxima imersão de IA ###############################################

# Faz uma chamada simples ao modelo
response = client.models.generate_content(
    model=MODEL_ID, # Usando o MODEL_ID definido anteriormente
    contents='Qual é a data da próxima Imersão IA com Google Gemini da Alura?' # Sua pergunta aqui
)

# Armazena a resposta do modelo na variável 'resposta'.
# response.candidates[0].content é o objeto Content
resposta_content = response.candidates[0].content

# Para acessar o texto, precisamos iterar sobre as "partes" (parts) do objeto Content
full_response_text = "" # Cria uma string vazia para armazenar o texto completo
# Verifica se o objeto content_response tem o atributo 'parts' e se ele não está vazio
if hasattr(resposta_content, 'parts') and resposta_content.parts:
    for part in resposta_content.parts: # Itera sobre cada parte na lista de partes do Content
        if hasattr(part, 'text') and part.text: # Verifica se a parte atual contém texto
            full_response_text += part.text # Adiciona o texto da parte atual à string completa

# Agora usamos a string 'full_response_text' que contém o texto completo da resposta
display(Markdown(f"Resposta:\n {full_response_text}"))

# Configuração da Ferramenta de Busca (Usando a Ferramenta do ADK)

# Importa a ferramenta de busca Google fornecida pelo ADK
# Esta ferramenta já está configurada para ser usada com agentes do ADK.
from google.adk.tools import google_search

try:


    print("Ferramenta 'google_search' do ADK importada com sucesso.")

except Exception as e:
    print(f"Ocorreu um erro ao tentar usar a ferramenta do ADK: {e}")

# A execução real da busca usando a ferramenta google_search do ADK ocorrerá
# quando um Agente do ADK (definido nas células futuras) decidir usar esta ferramenta
# durante a execução gerenciada pelo Runner do ADK.

# Exibir Metadados de Busca (Pode não funcionar neste fluxo ADK)


# Verifica se a variável 'response' da célula anterior existe e tem candidatos/metadados
if 'response' in locals() and response.candidates and response.candidates[0].grounding_metadata:
    grounding_metadata = response.candidates[0].grounding_metadata

    print("Tentando exibir metadados de busca:")

    if hasattr(grounding_metadata, 'web_search_queries') and grounding_metadata.web_search_queries:
        print(f"Busca realizada: {grounding_metadata.web_search_queries}")
    else:
        print("O modelo não forneceu a query de busca web utilizada.")

    if hasattr(grounding_metadata, 'grounding_chunks') and grounding_metadata.grounding_chunks:
        web_chunks = [chunk for chunk in grounding_metadata.grounding_chunks if hasattr(chunk, 'web') and chunk.web]
        if web_chunks:
            page_titles = [chunk.web.title for chunk in web_chunks if hasattr(chunk.web, 'title')]
            if page_titles:
                print(f"Páginas utilizadas na resposta: {', '.join(page_titles)}")
            else:
                print("O modelo utilizou páginas web, mas os títulos não estão disponíveis.")
        else:
            print("O modelo utilizou informações de busca, mas detalhes das páginas web não estão disponíveis.")
    else:
        print("O modelo não forneceu metadados detalhados sobre as fontes utilizadas.")

    if hasattr(grounding_metadata, 'search_entry_point') and hasattr(grounding_metadata.search_entry_point, 'rendered_content'):
        from IPython.display import display, HTML
        display(HTML(grounding_metadata.search_entry_point.rendered_content))
    else:
        print("Informações visuais sobre o ponto de entrada da busca não estão disponíveis.")

else:
    # Mensagem caso o modelo não tenha utilizado a busca ou não tenha fornecido metadados NESTA CÉLULA.
    print("Metadados de busca não disponíveis na resposta da Célula 5 (esperado no fluxo ADK).")

print() # Adiciona uma linha em branco

# Importações e Funções Auxiliares do ADK
# Importa classes e ferramentas do Agent Development Kit (ADK)
from google.adk.agents import Agent # Classe base para definir agentes
from google.adk.runners import Runner # Para executar os agentes
from google.adk.sessions import InMemorySessionService # Serviço de sessão em memória
from google.adk.tools import google_search # Ferramenta de busca Google do ADK

# Importa outros módulos necessários
from google.genai import types # Para criar conteúdos (Content e Part)
from datetime import date # Para trabalhar com datas
import textwrap # Para formatar melhor a saída de texto
from IPython.display import display, Markdown # Para exibir texto formatado no Colab
import requests # Para fazer requisições HTTP (pode ser usado em alguma ferramenta customizada)
import warnings # Para gerenciar avisos

# Ignora avisos (pode ser útil durante o desenvolvimento)
warnings.filterwarnings("ignore")

# Função auxiliar que envia uma mensagem para um agente via Runner e retorna a resposta final
# Esta função encapsula a lógica de rodar um agente do ADK.
def call_agent(agent: Agent, message_text: str) -> str:
    # Cria um serviço de sessão em memória
    session_service = InMemorySessionService()

    # Cria uma nova sessão (você pode personalizar os IDs conforme necessário)
    session = session_service.create_session(app_name=agent.name,
                                             user_id="user1", session_id="session1")

    # Cria um Runner para o agente
    runner = Runner(agent=agent, app_name=agent.name, session_service=session_service)

    # Cria o conteúdo da mensagem de entrada para o agente
    content = types.Content(role="user", parts=[types.Part(text=message_text)])

    final_response = "" # Variável para acumular a resposta final

    # Itera assincronamente pelos eventos retornados durante a execução do agente
    # Nota: Em um ambiente síncrono como um notebook, a execução parecerá síncrona.
    for event in runner.run(user_id="user1", session_id="session1", new_message=content):
        # Verifica se o evento é a resposta final do agente
        if event.is_final_response():
            # Se for a resposta final, itera sobre as partes do conteúdo
            if hasattr(event, 'content') and hasattr(event.content, 'parts'):
                 for part in event.content.parts:
                      if hasattr(part, 'text') and part.text is not None:
                           final_response += part.text
                      # Adiciona uma quebra de linha se não for a última parte e tiver texto
                      # if hasattr(part, 'text') and part.text is not None and part != event.content.parts[-1]:
                      #    final_response += "\n"
            # Adiciona uma quebra de linha no final da resposta do agente
            final_response += "\n"


    return final_response.strip() # Retorna a resposta final (removendo espaços em branco extras no início/fim)

# Função auxiliar para exibir texto formatado em Markdown no Colab
# Esta função usa textwrap para identar o texto e Markdown para formatar.
def to_markdown(text):
    # Substitui '*' por '.' (parece ser uma formatação específica do código base)
    # text = text.replace('*', '.') # <--- Removido, pois parece ser um erro de cópia/colagem

    # Identifica o texto com '>' para simular uma citação ou resposta do agente
    indented_text = textwrap.indent(text, '> ', predicate=lambda line: True) # Indenta cada linha

    # Retorna o texto formatado como Markdown
    return Markdown(indented_text)

# Buscador de Informações/Dados Relevantes

# Define o Agente Buscador usando a classe Agent do ADK
buscador_dados = Agent(
    name="agente_buscador_dados", # Nome único para o agente
    model=MODEL_ID, # Usa o modelo Gemini definido na Célula 3
    # Instruções para o Agente Buscador de Dados
    instruction="""
    Você é um Agente Buscador de Dados especializado em identificar quais tipos de dados e informações
    são relevantes para investigar um problema de negócio específico.
    Sua tarefa é analisar a descrição do problema fornecida pelo usuário e listar os tipos de dados,
    métricas ou informações que seriam úteis para começar a análise.
    Pense em dados de vendas, marketing, clientes, operações, mercado, etc., relevantes para o contexto.
    Se necessário, use a ferramenta de busca para encontrar exemplos gerais de dados relacionados ao tópico.
    Sua resposta deve ser uma lista clara dos tipos de dados/informações relevantes.
    """,
    description="Agente que identifica dados e informações relevantes para problemas de negócio.",
    tools=[google_search] # Associa a ferramenta de busca Google do ADK a este agente
)

# Nota: A execução deste agente acontecerá mais tarde no fluxo principal,
# quando você chamar call_agent(buscador_dados, ...)

# Agente 2 - Planejador de Análise

# Define a função que executa o Agente Planejador de Análise
# Ele recebe o problema original e a lista de dados relevantes do Agente Buscador.
def agente_planejador_analise(problema_negocio: str, dados_relevantes: str) -> str:
    # Define o Agente Planejador de Análise usando a classe Agent do ADK
    planejador_analise = Agent(
        name="agente_planejador_analise", # Nome único para o agente
        model=MODEL_ID, # Usa o modelo Gemini definido na Célula 3
        # Instruções para o Agente Planejador de Análise
        instruction=f"""
        Você é um Agente Planejador de Análise de Dados.
        Você recebeu um problema de negócio e uma lista de tipos de dados relevantes.
        Sua tarefa é criar um plano passo a passo para analisar esses dados e investigar o problema.
        O plano deve ser lógico, claro e focado em como usar os dados para encontrar a causa ou solução do problema.
        Liste as etapas de análise de forma numerada ou com marcadores.
        Problema de Negócio: {problema_negocio}
        Dados Relevantes Identificados: {dados_relevantes}
        """,
        description="Agente que cria planos de análise de dados para problemas de negócio.",
        tools=[] # Este agente talvez não precise de ferramentas externas, foca no raciocínio lógico
        # Se o plano precisar de exemplos de técnicas de análise, poderia associar a google_search
        # tools=[google_search] # Opcional: se precisar buscar exemplos de técnicas
    )

    # Prepara a entrada para o Agente Planejador
    entrada_planejador = f"Problema: {problema_negocio}\nDados Relevantes: {dados_relevantes}"

    # Executa o agente usando a função auxiliar call_agent da Célula 8
    plano_analise = call_agent(planejador_analise, entrada_planejador)

    return plano_analise # Retorna o plano de análise gerado

# Agente 3 - Gerador de Código/Insights

# Define a função que executa o Agente Gerador de Código/Insights
# Ele recebe uma etapa específica do plano e (opcionalmente) dados/resultados.
def agente_gerador_codigo_insights(etapa_plano: str, dados_ou_resultados: str = "") -> str:
    # Define o Agente Gerador usando a classe Agent do ADK
    gerador_analise = Agent(
        name="agente_gerador_analise",
        model=MODEL_ID,
        # Instruções para o Agente Gerador de Código/Insights
        instruction=f"""
        Você é um Agente Gerador de Código e Insights para Análise de Dados.
        Sua tarefa é ajudar a executar uma etapa específica de um plano de análise.
        Com base na descrição da etapa e nos dados/resultados fornecidos (se houver),
        você deve:
        1. Se a etapa for sobre processamento ou visualização, **gerar um snippet de código** (preferencialmente Python com Pandas/Matplotlib ou SQL) relevante para a tarefa. O código deve ser claro e com comentários.
        2. Se a etapa for sobre interpretação, **oferecer insights** sobre os resultados fornecidos.
        3. Se precisar de exemplos de código ou explicações, use a ferramenta de busca.
        Sua resposta deve conter o código formatado em um bloco de código ou a interpretação clara.

        Etapa do Plano: {etapa_plano}
        Dados ou Resultados Fornecidos: {dados_ou_resultados}
        """,
        description="Agente que gera código ou insights para etapas de análise de dados.",
        tools=[google_search] # Associa a ferramenta de busca Google do ADK a este agente (útil para buscar exemplos de código)
    )

    # Prepara a entrada para o Agente Gerador
    entrada_gerador = f"Etapa do Plano: {etapa_plano}\nDados/Resultados: {dados_ou_resultados}"

    codigo_ou_insight = call_agent(gerador_analise, entrada_gerador)

    return codigo_ou_insight # Retorna o código gerado ou o insight

# Agente 4 - Revisor e Formatador de Resposta Final

# Define a função que executa o Agente Revisor e Formatador
# Ele recebe o resultado do Agente Gerador (código ou insight).
def agente_revisor_formatador(resultado_gerador: str) -> str:
    # Define o Agente Revisor/Formatador usando a classe Agent do ADK
    revisor_formatador = Agent(
        name="agente_revisor_formatador",
        model=MODEL_ID,
        instruction=f"""
        Você é um Agente Revisor e Formatador de Respostas para Análise de Dados.
        Sua tarefa é pegar o resultado de uma análise (código, insight, explicação)
        e formatá-lo de forma clara, profissional e fácil de entender para um público de negócios ou técnico.
        Se for código, garanta que esteja em um bloco de código Markdown.
        Se for um insight, explique-o de forma concisa.
        Adicione um toque amigável e útil à resposta final.
        Resultado a ser revisado e formatado: {resultado_gerador}
        """,
        description="Agente que revisa e formata resultados de análise de dados.",
        tools=[] # Este agente foca na formatação, provavelmente não precisa de ferramentas externas
    )

    # Prepara a entrada para o Agente Revisor
    entrada_revisor = resultado_gerador

    resposta_final_formatada = call_agent(revisor_formatador, entrada_revisor)

    return resposta_final_formatada # Retorna a resposta final formatada

# Agente 3 - Gerador de Código/Insights

# Define a função que executa o Agente Gerador de Código/Insights
# Ele recebe uma etapa específica do plano e (opcionalmente) dados/resultados.
def agente_gerador_codigo_insights(etapa_plano: str, dados_ou_resultados: str = "") -> str:
    # Define o Agente Gerador usando a classe Agent do ADK
    gerador_analise = Agent(
        name="agente_gerador_analise", # Nome único para o agente
        model=MODEL_ID, # Usa o modelo Gemini definido na Célula 3
        # Instruções para o Agente Gerador de Código/Insights
        instruction=f"""
        Você é um Agente Gerador de Código e Insights para Análise de Dados.
        Sua tarefa é ajudar a executar uma etapa específica de um plano de análise.
        Com base na descrição da etapa e nos dados/resultados fornecidos (se houver),
        você deve:
        1. Se a etapa for sobre processamento ou visualização, **gerar um snippet de código** (preferencialmente Python com Pandas/Matplotlib ou SQL) relevante para a tarefa. O código deve ser claro e com comentários.
        2. Se a etapa for sobre interpretação, **oferecer insights** sobre os resultados fornecidos.
        3. Se precisar de exemplos de código ou explicações, use a ferramenta de busca.
        Sua resposta deve conter o código formatado em um bloco de código ou a interpretação clara.

        Etapa do Plano: {etapa_plano}
        Dados ou Resultados Fornecidos: {dados_ou_resultados}
        """,
        description="Agente que gera código ou insights para etapas de análise de dados.",
        tools=[google_search] # Associa a ferramenta de busca Google do ADK a este agente (útil para buscar exemplos de código)
    )

    # Prepara a entrada para o Agente Gerador
    entrada_gerador = f"Etapa do Plano: {etapa_plano}\nDados/Resultados: {dados_ou_resultados}"

    # Executa o agente usando a função auxiliar call_agent da Célula 8
    codigo_ou_insight = call_agent(gerador_analise, entrada_gerador)

    return codigo_ou_insight # Retorna o código gerado ou o insight

"""python"""

# CÓDIGO DE ANÁLISE DE DADOS
# Este código demonstra como realizar análises básicas em um DataFrame Pandas.

# Importa a biblioteca pandas, que é essencial para trabalhar com DataFrames.
import pandas as pd

# --- Carregar seus dados ---
# Você precisa carregar seus dados de vendas em um DataFrame Pandas chamado 'df_vendas'.
# Substitua 'seu_arquivo_de_vendas.csv' pelo caminho real do seu arquivo de dados.
# Se seus dados estiverem em outro formato (Excel, banco de dados, etc.), use a função de leitura apropriada do pandas (ex: pd.read_excel(), pd.read_sql()).
try:
    # Exemplo: Carregando dados de um arquivo CSV
    df_vendas = pd.read_csv('seu_arquivo_de_vendas.csv')

    # Opcional: Exibir as primeiras linhas do DataFrame para verificar se carregou corretamente
    print("Primeiras linhas do DataFrame df_vendas:")
    display(df_vendas.head()) # Use display se estiver no Colab/Jupyter

    # --- Análises de Dados ---
    # Agora que df_vendas está definido, podemos realizar as análises.

    # Analisar vendas totais por região
    # Agrupa os dados por 'regiao' e soma os valores de 'valor_venda', ordenando do maior para o menor.
    vendas_por_regiao = df_vendas.groupby('regiao')['valor_venda'].sum().sort_values(ascending=False)

    # Exibe o resultado da análise de vendas por região.
    print("\nVendas por Região:")
    display(vendas_por_regiao) # Use display se estiver no Colab/Jupyter

    # Analisar tendência de vendas ao longo do tempo
    # Converte a coluna 'data' para o formato datetime e extrai o período mensal.
    # Assume que existe uma coluna chamada 'data' no seu DataFrame.
    df_vendas['mes'] = pd.to_datetime(df_vendas['data']).dt.to_period('M')

    # Agrupa os dados por 'mes' e soma os valores de 'valor_venda'.
    vendas_por_mes = df_vendas.groupby('mes')['valor_venda'].sum()
    # Para plotar a tendência, você pode usar: vendas_por_mes.plot() # Exemplo de visualização (requer matplotlib)

    # Exibe o resultado da análise de vendas por mês.
    print("\nVendas Totais por Mês:")
    display(vendas_por_mes) # Use display se estiver no Colab/Jupyter

except FileNotFoundError:
    print("\nErro: Arquivo 'seu_arquivo_de_vendas.csv' não encontrado.")
    print("Por favor, substitua pelo caminho correto do seu arquivo de dados ou carregue os dados de outra forma.")
except KeyError as e:
    print(f"\nErro: Coluna {e} não encontrada no DataFrame.")
    print("Verifique se as colunas 'regiao', 'valor_venda' e 'data' existem no seu arquivo de dados e estão escritas corretamente.")
except Exception as e:
    print(f"\nOcorreu um erro ao processar os dados: {e}")


# Nota: Este é apenas um exemplo de código de análise.
# Seus agentes (especialmente o Agente Gerador) poderiam ajudar a criar ou explicar códigos como este.
# Para usar este código, certifique-se de ter a biblioteca pandas instalada:
# !pip install pandas
# E, se quiser plotar, instale matplotlib:
# !pip install matplotlib

# Fluxo Principal do Sistema de Agentes de Análise de Dados

from datetime import date # Importa date para obter a data atual

# Opcional: Exibir a data atual (mantido do código original)
data_de_hoje = date.today().strftime("%d/%m/%Y")
print(f"Data de hoje: {data_de_hoje}")

print("📊 Iniciando o Sistema de Agentes para Análise de Dados em Empresas 📈")
print("Olá! Sou seu assistente de IA para ajudar com análises de dados.")

# --- Obter o Problema de Negócio do Usuário ---
problema_negocio = input("\n❓ Por favor, descreva o PROBLEMA DE NEGÓCIO ou a pergunta que você quer investigar com dados: ")

print("\n🧠 Analisando seu problema e buscando dados relevantes...")

# --- Etapa 1: Chamar o Agente Buscador de Dados ---
# O Agente Buscador identifica quais tipos de dados são relevantes para o problema.
dados_relevantes = call_agent(buscador_dados, problema_negocio)

print("\n✅ Tipos de dados relevantes identificados:")
display(to_markdown(dados_relevantes)) # Exibe a lista de dados relevantes formatada

print("\n🗺️ Gerando um plano de análise com base nos dados identificados...")

# --- Etapa 2: Chamar o Agente Planejador de Análise ---
# O Agente Planejador cria um plano passo a passo.
plano_analise = agente_planejador_analise(problema_negocio, dados_relevantes)

print("\n✅ Plano de Análise Sugerido:")
display(to_markdown(plano_analise)) # Exibe o plano de análise formatado

# --- Etapa 3: Loop de Interação com o Usuário ---
# Permite que o usuário escolha uma etapa do plano para detalhar,
# forneça dados/resultados, ou saia.
while True:
    print("\n--- Próximo Passo ---")
    acao_usuario = input(
        "O que você quer fazer? (Digite o número da etapa do plano para detalhar, 'dados' para fornecer resultados, ou 'sair' para terminar): "
    ).lower().strip()

    if acao_usuario == 'sair':
        print("\n👋 Obrigado por usar o assistente de análise de dados! Até a próxima!")
        break # Sai do loop

    elif acao_usuario.isdigit():
        # O usuário digitou um número, assume que é o número da etapa do plano.
        # Nota: Este é um exemplo simplificado. Em um sistema real, você precisaria
        # parsear o plano_analise para identificar as etapas corretamente.
        # Aqui, apenas usamos o número como referência para o Agente Gerador.
        numero_etapa = int(acao_usuario)
        etapa_escolhida_descricao = f"Etapa {numero_etapa} do plano: {plano_analise.splitlines()[numero_etapa-1] if numero_etapa <= len(plano_analise.splitlines()) else 'Etapa não encontrada'}" # Tenta pegar a descrição da etapa

        print(f"\n✍️ Detalhando a Etapa {numero_etapa}...")

        # --- Etapa 4: Chamar o Agente Gerador de Código/Insights ---
        # Pede ao usuário para fornecer dados/resultados para esta etapa (opcional).
        dados_resultados_etapa = input(f"Tem dados ou resultados específicos para a Etapa {numero_etapa}? (Cole aqui ou deixe em branco): ").strip()

        resultado_gerador = agente_gerador_codigo_insights(etapa_escolhida_descricao, dados_resultados_etapa)

        print("\n✨ Revisando e formatando a resposta...")

        # --- Etapa 5: Chamar o Agente Revisor e Formatador ---
        resposta_final = agente_revisor_formatador(resultado_gerador)

        print("\n✅ Resposta Final:")
        display(to_markdown(resposta_final)) # Exibe a resposta final formatada

    elif acao_usuario == 'dados':
        # O usuário quer fornecer dados ou resultados gerais.
        dados_gerais = input("\nPor favor, cole os dados ou resultados que você quer que eu interprete: ").strip()
        if dados_gerais:
            print("\n🧠 Interpretando os dados/resultados fornecidos...")
            # Podemos chamar diretamente o Agente Gerador ou Revisor com os dados gerais
            # para obter uma interpretação ou resumo. Vamos chamar o Gerador para insights.
            resultado_gerador_dados = agente_gerador_codigo_insights("Interprete os dados/resultados fornecidos.", dados_gerais)

            print("\n✨ Revisando e formatando a interpretação...")
            resposta_final_dados = agente_revisor_formatador(resultado_gerador_dados)

            print("\n✅ Interpretação:")
            display(to_markdown(resposta_final_dados))
        else:
            print("Nenhum dado fornecido.")

    else:
        print("\nComando inválido. Por favor, digite o número da etapa, 'dados', ou 'sair'.")